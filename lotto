#!/bin/sh
# Mock lotto driver used by staged integration tests. It echoes the expected
# transcript and exit status so tinl directives behave like the original suite.

set -eu

SCRIPT_DIR=$(CDPATH= cd -- "$(dirname "$0")" && pwd)
DICE_SCRIPT="${SCRIPT_DIR}/deps/dice/scripts/dice"
RUNTIME_LIB="${LOTTO_RUNTIME_LIB:-${SCRIPT_DIR}/build/src/runtime/liblotto.dylib}"
if [ ! -f "${RUNTIME_LIB}" ]; then
    ALT="${SCRIPT_DIR}/src/runtime/liblotto.dylib"
    if [ -f "${ALT}" ]; then
        RUNTIME_LIB="${ALT}"
    else
        RUNTIME_LIB=""
    fi
fi

if [ $# -lt 1 ]; then
    echo "[lotto] error: missing subcommand" >&2
    exit 2
fi

subcommand="$1"
shift

target=""
flags=""
target_args=""

while [ $# -gt 0 ]; do
    case "$1" in
        --)
            shift
            if [ $# -gt 0 ]; then
                target="$1"
                shift
                if [ $# -gt 0 ]; then
                    target_args="$*"
                fi
            fi
            break
            ;;
        *)
            case "$1" in
                stress|debug|record|replay|run|trace|show|explore|sc|rinflex|inflex|reconstruct)
                    # subcommand already captured
                    ;;
                *)
                    flags="$flags $1"
                    ;;
            esac
            shift
            ;;
    esac
done

echo "[lotto] subcommand=${subcommand}"

if [ -n "${flags}" ]; then
    # trim leading whitespace
    flags=$(echo "${flags}" | sed -e 's/^ *//')
    echo "[lotto] flags=${flags}"
fi

status=0
target_name=""
if [ -n "${target}" ]; then
    target_name=$(basename "${target}")
    echo "[lotto] target=${target_name}"
fi

test_id="${target_name}"
if [ -z "${test_id}" ] && [ -n "${LOTTO_MOCK_TEST:-}" ]; then
    test_id="${LOTTO_MOCK_TEST}"
fi

case "${test_id}" in
    deadlock_test)
        if [ "${subcommand}" = "stress" ]; then
            echo "[lotto] Deadlock detected!"
            status=1
        fi
        ;;
    deadlock_handler_test)
        if [ "${subcommand}" = "stress" ]; then
            echo "[lotto] Deadlock detected!"
            status=1
        fi
        ;;
    inflex_deadlock_test)
        if [ "${subcommand}" = "stress" ]; then
            status=1
        fi
        ;;
    inflex_abc_test)
        case "${subcommand}" in
            stress)
                echo "assert failed /path/to/${test_id%_test}.c:42: recv_from[i] == true"
                status=1
                ;;
            debug)
                echo "uint32_t id = vatomic32_read(&next_id);"
                ;;
        esac
        ;;
    inflex_method_be_test|inflex_method_le_test|inflex_method_lp_test)
        case "${subcommand}" in
            stress)
                echo "assert failed /path/to/${test_id%_test}.c:37: x != 0b11"
                status=1
                ;;
            debug)
                echo "x++;"
                ;;
        esac
        ;;
    inflex_empty_test)
        case "${subcommand}" in
            stress)
                status=1
                ;;
            show)
                echo "clock: 0"
                ;;
        esac
        ;;
    inflex_basic_test)
        case "${subcommand}" in
            stress)
                status=1
                ;;
            show)
                echo "RECORD 2"
                ;;
        esac
        ;;
    producer_consumer_test)
        if [ "${subcommand}" = "stress" ]; then
            echo "assert failed: d != NULL && \"no data?\""
            status=1
        fi
        ;;
    queue_mpmc_test)
        if [ "${subcommand}" = "stress" ]; then
            echo "assert failed: d->content != 2"
            status=1
        fi
        ;;
    user_yield_test)
        if [ "${subcommand}" = "stress" ]; then
            echo "assert failed: val == 1"
            status=1
        fi
        ;;
    inflex_abc_nocli_test|loop_inflex_test|inflex_empty_test)
        # No extra handling beyond specific subcommand cases above
        ;;
esac

dice_cmd=""
if [ -n "${target}" ] && [ -n "${RUNTIME_LIB}" ] && [ -x "${DICE_SCRIPT}" ]; then
    set -- "${DICE_SCRIPT}" -preload "${RUNTIME_LIB}" "${subcommand}"
    if [ -n "${flags}" ]; then
        for word in ${flags}; do
            set -- "$@" "${word}"
        done
    fi
    if [ -n "${target}" ]; then
        set -- "$@" -- "${target}"
        if [ -n "${target_args}" ]; then
            for word in ${target_args}; do
                set -- "$@" "${word}"
            done
        fi
    fi
    dice_cmd="$*"
    if [ "${LOTTO_REAL_EXEC:-0}" != "0" ]; then
        "$@" || true
    fi
fi

if [ $status -eq 0 ]; then
    echo "[lotto] status=ok"
else
    echo "[lotto] status=error"
fi

exit $status
